var AOC =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util_aoc_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/aoc_utils */ \"./src/util/aoc_utils.js\");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar Tile = /*#__PURE__*/function () {\n  function Tile(data) {\n    var _this = this;\n\n    _classCallCheck(this, Tile);\n\n    this.rows = data.split('\\r\\n');\n    this.imageRows = this.rows.slice(1, this.rows.length); // props\n\n    this.id = parseInt(this.rows[0].replace(/[^0-9]/g, ''));\n    this.top = this.imageRows[0];\n    this.right = this.imageRows.map(function (e) {\n      return e[e.length - 1];\n    }).join('');\n    this.bottom = this.reverse(this.imageRows[this.imageRows.length - 1]);\n    this.left = this.reverse(this.imageRows.map(function (e) {\n      return e[0];\n    }).join(''));\n    this.sides = [this.top, this.right, this.bottom, this.left];\n    this.sidesInverse = this.sides.map(function (side) {\n      return _this.reverse(side);\n    });\n    this.rot = 0;\n    this.flipped = false;\n    this.index = -1; // get tile as array\n\n    this.tile = new Array(100);\n\n    for (var y = 0; y < 10; y++) {\n      for (var x = 0; x < 10; x++) {\n        var row = this.imageRows[y];\n        var index = y * 10 + x;\n        this.tile[index] = row[x];\n      }\n    } // build image\n\n\n    this.size = this.top.length;\n    this.imageSize = 8;\n    this.image = new Array(64);\n\n    for (var _y = 1; _y < 9; _y++) {\n      for (var _x = 1; _x < 9; _x++) {\n        var _row = this.imageRows[_y];\n\n        var _index = (_y - 1) * this.imageSize + (_x - 1);\n\n        this.image[_index] = _row[_x];\n      }\n    }\n  }\n\n  _createClass(Tile, [{\n    key: \"propagateIndex\",\n    value: function propagateIndex(i) {\n      this.index = i;\n      var x = this.index % this.puzzleSize;\n      var y = (this.index - x) / this.puzzleSize; // propagate right\n\n      if (x < this.puzzleSize - 1) {\n        var next = this.getMatchForSide(this.right);\n        this.rotateFlipTileToMatch('right', next);\n        next.propagateIndex(this.index + 1);\n      } // propagate down\n\n\n      if (y < this.puzzleSize - 1) {\n        var _next = this.getMatchForSide(this.bottom);\n\n        this.rotateFlipTileToMatch('bottom', _next);\n\n        _next.propagateIndex(this.index + this.puzzleSize);\n      }\n    }\n  }, {\n    key: \"rotateFlipTileToMatch\",\n    value: function rotateFlipTileToMatch(side, tile) {\n      var inv = null;\n      if (side == 'left') inv = 'right';else if (side == 'bottom') inv = 'top';else if (side == 'right') inv = 'left';else inv = 'bottom';\n      var rots = 0;\n\n      while (this[side] != this.reverse(tile[inv])) {\n        tile.rotate();\n        rots += 1;\n\n        if (rots == 4) {\n          tile.flip();\n        } else if (rots == 8) {\n          break;\n        }\n      }\n\n      if (rots == 8) {\n        console.log('ERROR rotating tile');\n        console.log(this, tile);\n        console.log('LAST ATTEMPT', side, this[side], inv, tile[inv]);\n      } else {// console.log('SUCCESS', side, this[side], inv, tile[inv]);\n      }\n    }\n  }, {\n    key: \"profile\",\n    value: function profile(tiles) {\n      var _this2 = this;\n\n      this.ref = {\n        tiles: tiles\n      };\n      this.puzzleSize = Math.sqrt(tiles.length);\n      this.matchProfile = [0, 0, 0, 0];\n      this.matches = tiles.filter(function (tile) {\n        return tile.id !== _this2.id && _this2.isMatch(tile);\n      });\n      this.isCorner = this.matches.length == 2;\n      this.isEdge = this.matches.length == 3;\n      this.isCentre = this.matches.length == 4;\n    }\n  }, {\n    key: \"isMatch\",\n    value: function isMatch(tile) {\n      var _this3 = this;\n\n      var match = false;\n      this.sides.forEach(function (side, i) {\n        if (tile.sidesInverse.includes(side) || tile.sides.includes(side)) {\n          match = true;\n          _this3.matchProfile[i] += 1;\n        }\n      });\n      return match;\n    }\n  }, {\n    key: \"getMatchForSide\",\n    value: function getMatchForSide(side) {\n      return this.matches.find(function (tile) {\n        return tile.sidesInverse.includes(side) || tile.sides.includes(side);\n      });\n    }\n  }, {\n    key: \"print\",\n    value: function print() {\n      var out = '';\n\n      for (var y = 0; y < this.imageSize; y++) {\n        for (var x = 0; x < this.imageSize; x++) {\n          var index = y * this.imageSize + x;\n          out += this.image[index];\n        }\n\n        out += '\\n';\n      }\n\n      console.log(out);\n    }\n  }, {\n    key: \"bakeTransform\",\n    value: function bakeTransform() {\n      console.log(this.id, this.rot, this.flipped);\n      this.bakedTile = transformImage(this.tile, this.rot, this.flipped);\n      this.bakedImage = transformImage(this.image, this.rot, this.flipped);\n    }\n  }, {\n    key: \"getBakedTile\",\n    value: function getBakedTile() {\n      return this.bakedTile;\n    }\n  }, {\n    key: \"getBakedImage\",\n    value: function getBakedImage() {\n      return this.bakedImage;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate() {\n      var top = this.top;\n      var right = this.right;\n      var bottom = this.bottom;\n      var left = this.left;\n      this.right = top;\n      this.bottom = right;\n      this.left = bottom;\n      this.top = left;\n      this.rot = (this.rot + 1) % 4;\n    }\n  }, {\n    key: \"flip\",\n    value: function flip() {\n      this.flipped = this.flipped == false;\n      this.top = this.reverse(this.top);\n      this.right = this.reverse(this.right);\n      this.bottom = this.reverse(this.bottom);\n      this.left = this.reverse(this.left);\n      var r = this.right;\n      this.right = this.left;\n      this.left = r;\n    }\n  }, {\n    key: \"reverse\",\n    value: function reverse(str) {\n      return str.split('').reverse().join('');\n    }\n  }]);\n\n  return Tile;\n}();\n\nvar printImage = function printImage(arr) {\n  var size = Math.sqrt(arr.length);\n  var print = '';\n\n  for (var y = 0; y < size; y++) {\n    for (var x = 0; x < size; x++) {\n      print += arr[y * size + x];\n    }\n\n    print += '\\n';\n  }\n\n  console.log(print);\n};\n\nvar countSeaMonsters = function countSeaMonsters(image) {\n  var monster = [].concat(_toConsumableArray(\"                  # \".split('')), _toConsumableArray(\"#    ##    ##    ###\".split('')), _toConsumableArray(\" #  #  #  #  #  #   \".split(''))).map(function (el, i) {\n    return el == ' ' ? null : {\n      x: i % 20,\n      y: (i - i % 20) / 20\n    };\n  }).filter(function (el) {\n    return el !== null;\n  });\n  var w = 20;\n  var h = 3;\n  w = 5;\n  h = 5;\n  monster = [].concat(_toConsumableArray(\"# ###\".split('')), _toConsumableArray(\"# #  \".split('')), _toConsumableArray(\"#####\".split('')), _toConsumableArray(\"  # #\".split('')), _toConsumableArray(\"### #\".split(''))).map(function (el, i) {\n    return el == ' ' ? null : {\n      x: i % w,\n      y: (i - i % w) / w\n    };\n  }).filter(function (el) {\n    return el !== null;\n  });\n  var size = Math.sqrt(image.length);\n  var count = 0;\n\n  var output = _toConsumableArray(image);\n\n  for (var x = 0; x < size - w; x++) {\n    for (var y = 0; y < size - h; y++) {\n      var found = true;\n\n      for (var i = 0; i < monster.length; i++) {\n        var x2 = x + monster[i].x;\n        var y2 = y + monster[i].y;\n        var index = y2 * size + x2;\n\n        if (image[index] !== '#') {\n          found = false;\n          break;\n        }\n      }\n\n      if (found) {\n        count += 1; // draw sea monster\n\n        for (var _i = 0; _i < monster.length; _i++) {\n          var _x2 = x + monster[_i].x;\n\n          var _y2 = y + monster[_i].y;\n\n          var _index2 = _y2 * size + _x2;\n\n          output[_index2] = \"O\";\n        }\n      }\n    }\n  }\n\n  if (count > 0) {\n    printImage(output);\n    console.log('SEA MONSTERS:', count);\n    var waves = 0;\n    output.forEach(function (w) {\n      waves += w == '#' ? 1 : 0;\n    });\n    console.log('WAVES:', waves);\n  }\n\n  return count;\n};\n\nvar transformImage = function transformImage(arr, rot, flip) {\n  var size = Math.sqrt(arr.length);\n  var output = new Array(arr.length);\n\n  for (var x = 0; x < size; x++) {\n    for (var y = 0; y < size; y++) {\n      var char = arr[y * size + x];\n      var x_ = x;\n      var y_ = y;\n      var x2 = -1;\n      var y2 = -1; // flip\n\n      if (flip) {\n        x_ = size - 1 - x_; // y_ = size - 1 - y_;\n      } // rotate coords\n\n\n      if (rot == 0) {\n        x2 = x_;\n        y2 = y_;\n      } else if (rot == 1) {\n        x2 = size - 1 - y_;\n        y2 = x_;\n      } else if (rot == 2) {\n        x2 = size - 1 - x_;\n        y2 = size - 1 - y_;\n      } else if (rot == 3) {\n        x2 = y_;\n        y2 = size - 1 - x_;\n      }\n\n      output[y2 * size + x2] = char;\n    }\n  }\n\n  return output;\n};\n\nvar App = /*#__PURE__*/function () {\n  function App() {\n    var _this4 = this;\n\n    _classCallCheck(this, App);\n\n    fetch('data/20.txt').then(function (res) {\n      return res.text();\n    }).then(function (text) {\n      _this4.text = text;\n      fetch('data/sample.txt').then(function (res) {\n        return res.text();\n      }).then(function (text) {\n        _this4.sample = text;\n\n        _this4.solve(_this4.sample); // this.solve(this.text);\n\n      });\n    });\n  }\n\n  _createClass(App, [{\n    key: \"solve\",\n    value: function solve(text) {\n      var _this5 = this;\n\n      // print result\n      var print = function print(tile) {\n        var size = Math.sqrt(tile.data.length);\n        var output = tile.data.map(function (e, i) {\n          return (i % size == 0 ? '\\n' : '') + e;\n        }).join('');\n        console.log(output);\n      }; // transform\n\n\n      var transform = function transform(tile, op) {\n        var size = Math.sqrt(tile.data.length);\n        var data = new Array(tile.data.length);\n        tile.data.forEach(function (e, i) {\n          var x = i % size;\n          var y = (i - x) / size;\n          var j = op == 'rotate' ? x * size + size - y - 1 : y * size + size - x - 1;\n          data[j] = e;\n        });\n        tile.data = data;\n        tile.edges = getEdges(data);\n      };\n\n      var flip = function flip(tile) {\n        transform(tile, 'flip');\n      };\n\n      var rotate = function rotate(tile) {\n        transform(tile, 'rotate');\n      }; // searching\n\n\n      var reverse = function reverse(str) {\n        return str.split('').reverse().join('');\n      };\n\n      var getEdges = function getEdges(arr) {\n        return [arr.slice(0, 10).join(''), arr.filter(function (e, i) {\n          return i % 10 == 9;\n        }).join(''), arr.slice(90, 100).reverse().join(''), arr.filter(function (e, i) {\n          return i % 10 == 0;\n        }).reverse().join('')];\n      };\n\n      var getMatches = function getMatches(tile, tiles) {\n        return tiles.filter(function (t) {\n          var search = [].concat(_toConsumableArray(t.edges), _toConsumableArray(t.edges.map(function (e) {\n            return _this5.reverse(e);\n          })));\n          return t.id !== tile.id && tile.edges.some(function (e) {\n            return search.includes(e);\n          });\n        });\n      };\n\n      var getMatch = function getMatch(edge, tiles) {\n        return tiles.find(function (t) {\n          var search = [].concat(_toConsumableArray(t.edges), _toConsumableArray(t.edges.map(function (e) {\n            return _this5.reverse(e);\n          })));\n          return t.id !== tile.id && tile.edges.some(function (e) {\n            return search.includes(e);\n          });\n        });\n      }; // init tiles\n\n\n      var tiles = text.trim().split('\\r\\n\\r\\n').map(function (block) {\n        var id = parseInt(block.replace(/[^0-9]/g, ''));\n        var data = block.replace(/[^#\\.]/g, '').split('');\n        var edges = getEdges(data);\n        return {\n          id: id,\n          data: data,\n          edges: edges\n        };\n      });\n      tiles.forEach(function (tile) {\n        tile.matches = getMatches(tile, tiles);\n      }); // part 1 -- find corners\n\n      var corners = tiles.filter(function (tile) {\n        return tile.matches.length == 2;\n      });\n      var p1 = corners[0].id * corners[1].id * corners[2].id * corners[3].id;\n      console.log(p1); // part 2 -- find sea dragons\n\n      /*\r\n      let tiles = text.trim().split('\\r\\n\\r\\n');\r\n      tiles = tiles.map(tile => new Tile(tile));\r\n      tiles.forEach((tile) => {\r\n        tile.profile(tiles);\r\n      });\r\n        // p1\r\n      const corners = tiles.filter(tile => tile.isCorner);\r\n      let p1 = corners[0].id * corners[1].id * corners[2].id * corners[3].id;\r\n      console.log(p1);\r\n        // p2 ???\r\n      let topLeft = corners.find(tile => {\r\n        return tile.isCorner && tile.matchProfile[0] == 0 && tile.matchProfile[3] == 0;\r\n      });\r\n      topLeft.propagateIndex(0);\r\n      console.log(topLeft.id);\r\n        // get puzzle array\r\n      tiles.sort((a, b) => (a.index - b.index));\r\n      tiles.forEach(tile => { tile.bakeTransform(); });\r\n        // get size\r\n      const size = Math.sqrt(tiles.length);\r\n        // display tiles\r\n      let tiledImage = new Array(tiles.length * 121);\r\n      for (let i=0; i<tiledImage.length; i++) {\r\n        tiledImage[i] = ' ';\r\n      }\r\n      for (let y=0; y<size; y++) {\r\n        for (let x=0; x<size; x++) {\r\n          const index = y * size + x;\r\n          const baked = tiles[index].getBakedTile();\r\n          baked.forEach((el, i) => {\r\n            let px = x * 11 + i % 10;\r\n            let py = y * 11 + (i - (i % 10)) / 10;\r\n            tiledImage[py * (size * 11) + px] = el;\r\n          });\r\n        }\r\n      }\r\n      printImage(tiledImage);\r\n        // create puzzle image\r\n      const puzzle = new Array(tiles.length * 64);\r\n      for (let y=0; y<size; y++) {\r\n        for (let x=0; x<size; x++) {\r\n          const index = y * size + x;\r\n          const baked = tiles[index].getBakedImage();\r\n          baked.forEach((el, i) => {\r\n            let px = x*8 + i%8;\r\n            let py = y*8 + (i - (i%8)) / 8;\r\n            puzzle[py * (size * 8) + px] = el;\r\n          });\r\n        }\r\n      }\r\n      // printImage(puzzle);\r\n        for (let rot=0; rot<4; rot++) {\r\n        for (let flipped=0; flipped<2; flipped++) {\r\n          let im = transformImage(puzzle, rot, flipped==1)\r\n          countSeaMonsters(im);\r\n        }\r\n      }\r\n      */\n      //console.log(puzzle);\n      //console.log(size);\n    }\n  }]);\n\n  return App;\n}();\n\nwindow.addEventListener('load', function () {\n  var app = new App();\n});\n\n//# sourceURL=webpack://AOC/./src/app.js?");

/***/ }),

/***/ "./src/util/aoc_utils.js":
/*!*******************************!*\
  !*** ./src/util/aoc_utils.js ***!
  \*******************************/
/*! exports provided: splitNewline, splitDoubleNewline, splitComma, keyValue, replaceAll, toNumbers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"splitNewline\", function() { return splitNewline; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"splitDoubleNewline\", function() { return splitDoubleNewline; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"splitComma\", function() { return splitComma; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyValue\", function() { return keyValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"replaceAll\", function() { return replaceAll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toNumbers\", function() { return toNumbers; });\n/** AOC parsing utilities */\nfunction sanitise(v) {\n  v = v.trim();\n  return isNaN(v) ? v : parseFloat(v);\n}\n\nfunction getLinebreak(input) {\n  return input.indexOf('\\r\\n') !== -1 ? '\\r\\n' : '\\n';\n}\n\nfunction splitNewline(input) {\n  var br = getLinebreak(input);\n  var res = input.trim().split(br);\n  return res.map(function (v) {\n    return sanitise(v);\n  });\n}\n\nfunction splitDoubleNewline(input) {\n  var br = getLinebreak(input);\n  var res = input.trim().split(br + br);\n  return res.map(function (v) {\n    return sanitise(v);\n  });\n}\n\nfunction splitComma(input) {\n  var res = input.trim().split(',');\n  return res.map(function (v) {\n    return sanitise(v);\n  });\n}\n\nfunction keyValue(input, delim) {\n  var split = input.trim().split(delim);\n  var key = split[0];\n  var value = sanitise(split.length > 1 ? split[1] : null);\n  return {\n    key: key,\n    value: value\n  };\n}\n\nfunction replaceAll(input, a, b) {\n  var re = new RegExp(a, 'g');\n  return input.replace(re, b);\n}\n\nfunction toNumbers(arr) {\n  return arr.map(function (el) {\n    return isNaN(el.trim()) ? el : parseFloat(el.trim());\n  });\n}\n\n\n\n//# sourceURL=webpack://AOC/./src/util/aoc_utils.js?");

/***/ })

/******/ });